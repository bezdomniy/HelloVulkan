#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 800
#define HEIGHT 600
#define WORKGROUP_SIZE 32

#define EPSILON 0.0001
#define MAXLEN 1000.0

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

struct Pixel{
  vec4 value;
};

layout(std140, binding = 0) buffer buf
{
   Pixel imageData[];
};

struct Camera 
{
  mat4 inverseTransform;
  float pixelSize;
  float halfWidth;
  float halfHeight;
};

struct Material {
    vec4 colour;
    float ambient;
    float diffuse;
    float specular;
    float shininess;
//     float reflective;
//     float transparency;
//     float refractiveIndex;

// //        std::shared_ptr<Pattern> pattern;
//     bool shadow = true;
};

struct Shape {
  
  mat4 inverseTransform;
  Material material;
  vec4 data[6];
  int typeEnum;
  int id;
};

// struct BVH {
//     mat4 inverseTransform;
//     Material material;
//     vec4 nodes[];
// };

layout (binding = 1) uniform UBO 
{
	vec4 lightPos;
	Camera camera;
} ubo;

layout (std140, binding = 2) buffer Shapes
{
	Shape shapes[ ];
};

layout (std140, binding = 3) buffer BVH
{
  mat4 inverseTransform;
  Material material;
  vec4 nodes[];
} bvh;

void rayForPixel(in vec2 p, out vec4 rayO, out vec4 rayD) {
  float xOffset = (p.x + 0.5) * ubo.camera.pixelSize;
  float yOffset = (p.y + 0.5) * ubo.camera.pixelSize;

  float worldX = ubo.camera.halfWidth - xOffset;
  float worldY = ubo.camera.halfHeight - yOffset;

  vec4 pixel = ubo.camera.inverseTransform *
                     vec4(worldX, worldY, -1.0, 1.0);
  rayO = ubo.camera.inverseTransform * vec4(0.0, 0.0, 0.0, 1.0);
  rayD = normalize(pixel - rayO);
}

void transformRay(in mat4 m, in vec4 rayO, in vec4 rayD, out vec4 nRayO, out vec4 nRayD) {
  nRayO = m * rayO;
  nRayD = m * rayD;
}

float sphereIntersect(in vec4 rayO, in vec4 rayD) {
  vec4 sphereToRay = rayO - vec4(0.0, 0.0, 0.0, 1.0);
  float a = dot(rayD, rayD);
  float b = 2 * dot(rayD, sphereToRay);
  float c =
      dot(sphereToRay, sphereToRay) - 1.0;
  float discriminant = b * b - 4 * a * c;

  if (discriminant < 0)
    return -1.0;

  float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
  float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

  if (t1 < t2) {
    return t1;
  }
  return t2;
}

float planeIntersect(in vec4 rayO, in vec4 rayD) {
    if (abs(rayD.y) < EPSILON)
        return -1.0;

    return -rayO.y / rayD.y;
}

float triangleIntersect(in vec4 rayO, in vec4 rayD,in vec4 p1,in vec4 p2,in vec4 p3, out vec2 uv) {
    vec3 e1 = vec3(p2 - p1);
    vec3 e2 = vec3(p3 - p1);

    vec3 dirCrossE2 = cross(vec3(rayD), e2);
    float det = dot(e1, dirCrossE2);
    if (abs(det) < EPSILON) {
        return -1.9;}

    float f = 1.0 / det;
    vec3 p1ToOrigin = vec3(rayO - p1);
    uv.x = f * dot(p1ToOrigin, dirCrossE2);
    if (uv.x < 0 || uv.x > 1) {
      return -1.0;
    }

    vec3 originCrossE1 = cross(p1ToOrigin, e1);
    uv.y = f * dot(vec3(rayD), originCrossE1);
    if (uv.y < 0 || (uv.x + uv.y) > 1) {
        return -1.0;
    }
    return f * dot(e2, originCrossE1);
}

int intersect(in vec4 rayO, in vec4 rayD, inout float resT, out vec2 uv)
{
	int id = -1;

	for (int i = 0; i < shapes.length(); i++)
	{
    vec4 nRayO, nRayD;
    transformRay(shapes[i].inverseTransform, rayO, rayD, nRayO, nRayD);
    
    float t = -1.0;
    if (shapes[i].typeEnum == 0) {
      t = sphereIntersect(nRayO, nRayD);
    }
    else if (shapes[i].typeEnum == 1) {
      t = planeIntersect(nRayO, nRayD);
    }
    else if (shapes[i].typeEnum == 2) {
      t = triangleIntersect(nRayO, nRayD, shapes[i].data[0], shapes[i].data[1], shapes[i].data[2], uv);
    }
		
		if ((t > EPSILON) && (t < resT))
		{
			id = shapes[i].id;
			resT = t;
		}
	}	

  vec4 nRayO, nRayD;
  transformRay(bvh.inverseTransform, rayO, rayD, nRayO, nRayD);
  for (int i = 0; i < bvh.nodes.length(); i+=6) {
    float t = -1.0;
    t = triangleIntersect(nRayO, nRayD, bvh.nodes[i], bvh.nodes[i+1], bvh.nodes[i+2], uv);
    if ((t > EPSILON) && (t < resT))
    {
      id = -(i/6); //TODO fix this hack, which is to differentiate with shapes. will fail at -1
      resT = t;
    }
  }

	return id;
}

vec4 normalToWorld(in vec4 normal, in mat4 inverseTransform)
{
  vec4 ret = transpose(inverseTransform) * normal;
  ret.w = 0.0;
  ret = normalize(ret);

  return ret;
}

vec4 normalAt(in vec4 point, in mat4 inverseTransform, in int typeEnum, in vec4 n1, in vec4 n2, in vec4 n3, in vec2 uv) {
  vec4 n = vec4(0.0);
  vec4 objectPoint = inverseTransform * point; // World to object

  if (typeEnum == 0) {
    n = objectPoint - vec4(0.0, 0.0, 0.0, 1.0);
  }
  else if (typeEnum == 1) {
    n = vec4(0.0,1.0,0.0,0.0);
  }
  else if (typeEnum == 2) {
    n = n2 * uv.x + n3 * uv.y + n1 * (1.0 - uv.x - uv.y);
    n.w = 0.0;
  }
  return normalToWorld(n, inverseTransform);
}

struct HitParams {
  vec4 point;
  vec4 normalv;
  vec4 eyev;
  vec4 reflectv;
  vec4 overPoint;
  vec4 underPoint;
};

HitParams getHitParams(in vec4 rayO, in vec4 rayD, in float t, in mat4 inverseTransform, in int typeEnum, in vec4 n1, in vec4 n2, in vec4 n3, in vec2 uv)
{
  HitParams hitParams;
  hitParams.point =
      rayO + normalize(rayD) * t;
  // TODO check that uv only null have using none-uv normalAt version
  hitParams.normalv =
      normalAt(hitParams.point, inverseTransform, typeEnum, n1,n2,n3, uv);
  hitParams.eyev = -rayD;

  if (dot(hitParams.normalv, hitParams.eyev) < 0)
  {
    // intersection.comps->inside = true;
    hitParams.normalv = -hitParams.normalv;
  }
  // else
  // {
  //   intersection.comps->inside = false;
  // }

  hitParams.reflectv =
      reflect(rayD, hitParams.normalv);
  hitParams.overPoint =
      hitParams.point + hitParams.normalv * EPSILON;
  hitParams.underPoint =
      hitParams.point - hitParams.normalv * EPSILON;

  return hitParams;
}

bool isShadowed(in vec4 point, in vec4 lightPos)
{
  vec4 v = lightPos - point;
  float distance = length(v);
  vec4 direction = normalize(v);

  // Ray ray = Ray(point, direction);
  // std::vector<Geometry::Intersection<Shape>> intersections =
  //     world.intersectRayShadow(ray);

  // Geometry::Intersection<Shape> *hit = Geometry::hit<Shape>(intersections);
  float t = MAXLEN;
  vec2 uv;
  int id = intersect(point, direction, t, uv);

  if ((id >= 0 && t < distance))
  {
    return true;
  }

  return false;
}

vec4 lighting(in Material material, in vec4 lightPos,
                              in HitParams hitParams, in bool shadowed)
{
  vec4 diffuse;
  vec4 specular;
  vec4 effectiveColour;

  vec4 intensity = vec4(1.0,1.0,1.0,1.0); // TODO temp placeholder

  effectiveColour = intensity * material.colour; //* light->intensity;

  vec4 ambient = effectiveColour * material.ambient;
  if (shadowed) {
    return ambient;
  }

  vec4 lightv = normalize(lightPos - hitParams.point);

  float lightDotNormal = dot(lightv, hitParams.normalv);
  if (lightDotNormal < 0)
  {
    diffuse = vec4(0.0, 0.0, 0.0,1.0);
    specular = vec4(0.0, 0.0, 0.0,1.0);
  }
  else
  {
    // compute the diffuse contribution​
    diffuse = effectiveColour * material.diffuse * lightDotNormal;

    // reflect_dot_eye represents the cosine of the angle between the
    // reflection vector and the eye vector. A negative number means the
    // light reflects away from the eye.​
    vec4 reflectv = reflect(-lightv, hitParams.normalv);
    float reflectDotEye = dot(reflectv, hitParams.eyev);

    if (reflectDotEye <= 0)
    {
      specular = vec4(0.0, 0.0, 0.0,1.0);
    }
    else
    {
      // compute the specular contribution​
      float factor = pow(reflectDotEye, material.shininess);
      specular = intensity * material.specular * factor;
    }
  }

  return (ambient + diffuse + specular);
}

vec4 renderScene(inout vec4 rayO, inout vec4 rayD, inout int id)
{
	vec4 color = vec4(0.0);
  vec2 uv;
	float t = MAXLEN;

	// Get intersected object ID
	int objectID = intersect(rayO, rayD, t, uv);
	
	if (objectID == -1)
	{
		return color;
	}
	
	// vec4 pos = rayO + t * rayD;
	// vec4 lightVec = normalize(ubo.lightPos - pos);				
	// vec3 normal;

	for (int i = 0; i < shapes.length(); i++)
	{
		if (objectID == shapes[i].id)
		{
      HitParams hitParams = getHitParams(rayO, rayD, t, shapes[i].inverseTransform, shapes[i].typeEnum, shapes[i].data[3], shapes[i].data[4], shapes[i].data[5], uv);

      bool shadowed = isShadowed(hitParams.overPoint, ubo.lightPos);
      color = lighting(shapes[i].material, ubo.lightPos,
                              hitParams, shadowed);
      // color = vec4(1.0,0.0,0.0,1.0);
		}
	}

  if (objectID < 0) {
      HitParams hitParams = getHitParams(rayO, rayD, t, bvh.inverseTransform, 2, bvh.nodes[objectID * -6], bvh.nodes[(objectID * -6) + 1], bvh.nodes[(objectID * -6) + 2], uv);

      bool shadowed = isShadowed(hitParams.overPoint, ubo.lightPos);
      color = lighting(bvh.material, ubo.lightPos,
                              hitParams, shadowed);
  }



	if (id == -1)
		return color;

	// id = objectID;

	// Shadows
	// t = length(ubo.lightPos - pos);
	// color *= calcShadow(pos, lightVec, id, t);
	
	// // Fog
	// color = fog(t, color);	
	
	// // Reflect ray for next render pass
	// reflectRay(rayD, normal);
	// rayO = pos;	
	
	return color;
}


void main() {

  /*
  In order to fit the work into workgroups, some unnecessary threads are launched.
  We terminate those threads here. 
  */
  if(gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
    return;

  // if (shapes.length() < 1) {
  // // if (ubo.camera.halfHeight > 0.0) {
  //   imageData[WIDTH * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].value = vec4(1.0,0.0,0.0,1.0);
  //   return;
  // }

  // imageData[WIDTH * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].value = vec4(ubo.lightPos,1.0);
  // return;

  vec4 rayO, rayD;

  rayForPixel(gl_GlobalInvocationID.xy, rayO, rayD);
		
	// Basic color path
	int id = 0;
	vec4 color = renderScene(rayO, rayD, id);

          
  // store the rendered mandelbrot set into a storage buffer:
  imageData[WIDTH * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].value = color;
}
